using Nethereum.BlockchainProcessing.BlockStorage.Entities;
using Nethereum.Contracts;
using Nethereum.Hex.HexTypes;
using Nethereum.Metamask;
using Nethereum.Unity.Contracts;
#if UNITY_WEBGL
  using Nethereum.Unity.Metamask;
#endif
using Nethereum.Unity.Rpc;
using Nethereum.Util;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using System;
using System.Collections;
using System.Numerics;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;
using Debug = UnityEngine.Debug;
using Sample.DotNet.Contracts.ERC20Token.ContractDefinition;
using Sample.DotNet.Contracts.ERC20Token;
using TransferFunction = Sample.DotNet.Contracts.ERC20Token.ContractDefinition.TransferFunction;

public class MultiplatformErc20Web3Task : MonoBehaviour
{
    public string Url = "http://localhost:8545";
    public BigInteger ChainId = 444444444500;
    public string PrivateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
    public string AddressTo = "0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe";
    private string _selectedAccountAddress; 
    private bool _isMetamaskInitialised = false;
    public decimal Amount = 1.1m;

    public InputField InputUrl;
    public InputField InputChainId;
    public InputField InputPrivateKey;
    public InputField InputAddressTo;
    public InputField InputAmount;

    public InputField ResultBalanceAddressTo;
    public InputField ResultTxnHash;
    public InputField ResultContractAddress;
    public Button BtnMetamaskConnect;
    public Text  LblError;

    private MetamaskHostProvider metamaskHost;

    void Start()
    {

        if (IsWebGL()) // using pk etc only on desktop as an example
        {
            InputUrl.enabled = false;
            InputPrivateKey.enabled = false;
            InputChainId.enabled = false;
            #if UNITY_WEBGL
                metamaskHost = MetamaskWebglHostProvider.CreateOrGetCurrentInstance();
                metamaskHost.SelectedAccountChanged += MetamaskHost_SelectedAccountChanged;
            #endif
        }
        else
        {
         
            InputUrl.text = Url;
            InputPrivateKey.text = PrivateKey;
            InputChainId.text = ChainId.ToString();
            BtnMetamaskConnect.enabled = false;
        }

        InputAddressTo.text = AddressTo;
        InputAmount.text = Amount.ToString();

    }

    private Task MetamaskHost_SelectedAccountChanged(string arg)
    {
        _selectedAccountAddress = arg;
        return Task.CompletedTask;
    }

    public bool IsWebGL()
    {
#if UNITY_WEBGL
      return true;
#else
      return false;
#endif
    }

    public async void DeployRequest()
    {
        await DeployERC20Async();
    }

    public async Task DeployERC20Async()
    {
        var web3 = await GetWeb3Async();
        web3.TransactionManager.UseLegacyAsDefault = true;
        web3.TransactionReceiptPolling.SetPollingRetryIntervalInMilliseconds(2000); // 2 seconds polling for receipts

        var deployContract = new ERC20TokenDeployment()
        {
            InitialAmount = Nethereum.Web3.Web3.Convert.ToWei(10000000),
            TokenName = "Nethereum Demo",
            TokenSymbol = "NETHER",
            DecimalUnits = 18,
        };

        var deploymentHandler = web3.Eth.GetContractDeploymentHandler<ERC20TokenDeployment>();
        var transactionReceiptDeployment = await deploymentHandler.SendRequestAndWaitForReceiptAsync(deployContract);
        var contractAddress = transactionReceiptDeployment.ContractAddress;
        ResultContractAddress.text = contractAddress;

        //OR using the service generated by the code generator
        //var transactionReceiptDeployment = await ERC20TokenService.DeployContractAndWaitForReceiptAsync((Web3)web3, deployContract);
        //var contractAddress = transactionReceiptDeployment.ContractAddress;
        //ResultContractAddress.text = contractAddress;

    }

    public async void TransferRequest()
    {
        await TransferErc20AndGetBalanceAsync();
        
    }

    public async Task TransferErc20AndGetBalanceAsync()
    {

        var web3 = await GetWeb3Async();
        web3.TransactionManager.UseLegacyAsDefault = true;
        web3.TransactionReceiptPolling.SetPollingRetryIntervalInMilliseconds(2000); // 2 seconds polling for receipts
        //Note this could use the services generated by the code generator to simplify it further
        //or web3.Eth.ERC20 presets 
        AddressTo = InputAddressTo.text;
        Amount = System.Decimal.Parse(InputAmount.text);
        var contractAddress = ResultContractAddress.text;

        var erc20Service = new ERC20TokenService(web3, contractAddress);
        var transactionTransferReceipt = await erc20Service.TransferRequestAndWaitForReceiptAsync(AddressTo,
            UnitConversion.Convert.ToWei(Amount));

        ResultTxnHash.text = transactionTransferReceipt.TransactionHash;

        var balanceReceiver = await erc20Service.BalanceOfQueryAsync(AddressTo);
        ResultBalanceAddressTo.text = balanceReceiver.ToString();
        Console.WriteLine("Balance of receiver after transfer: " + balanceReceiver);

        var transferEvent = transactionTransferReceipt.DecodeAllEvents<TransferEventDTO>();
        Debug.Log("Transferred amount from event: " + transferEvent[0].Event.Value);

        var transferEventHandler = web3.Eth.GetEvent<TransferEventDTO>(contractAddress);
        var filterInput = transferEventHandler.CreateFilterInput(_selectedAccountAddress);
        var events = await transferEventHandler.GetAllChangesAsync(filterInput);
        Debug.Log("Transferred amount from get logs event: " + events[0].Event.Value);

       
    }

    public void DisplayError(string errorMessage)
    {
        LblError.text = errorMessage;
    }

    public void MetamaskConnect()
    {
#if UNITY_WEBGL
        if (IsWebGL())
        {
            if (MetamaskWebglInterop.IsMetamaskAvailable())
            {
                MetamaskWebglInterop.EnableEthereum(gameObject.name, nameof(EthereumEnabled), nameof(DisplayError));
            }
            else
            {
                DisplayError("Metamask is not available, please install it");
            }
        }
#endif

    }

    public void EthereumEnabled(string addressSelected)
    {
#if UNITY_WEBGL
        if (IsWebGL())
        {
            if (!_isMetamaskInitialised)
            {
                MetamaskWebglInterop.EthereumInit(gameObject.name, nameof(NewAccountSelected), nameof(ChainChanged));
                MetamaskWebglInterop.GetChainId(gameObject.name, nameof(ChainChanged), nameof(DisplayError));
                _isMetamaskInitialised = true;
            }
            NewAccountSelected(addressSelected);
        }
#endif
    }

    public void ChainChanged(string chainId)
    {
        print(chainId);
        ChainId = new HexBigInteger(chainId).Value;
        InputChainId.text = ChainId.ToString();
    }

    public void NewAccountSelected(string accountAddress)
    {
        _selectedAccountAddress = accountAddress;
    }

    private string GetSelectedAccount()
    {
        return _selectedAccountAddress;
    }

    private async Task<IWeb3> GetWeb3Async()
    {
#if UNITY_WEBGL
        await metamaskHost.EnableProviderAsync();
        _selectedAccountAddress = metamaskHost.SelectedAccount;
        return await metamaskHost.GetWeb3Async();
#else
        Url = InputUrl.text;
        PrivateKey = InputPrivateKey.text;
        ChainId = BigInteger.Parse(InputChainId.text);
        var account = new Account(PrivateKey, ChainId);
        _selectedAccountAddress = account.Address;
        return new Web3(account, Url);
#endif
    }

}
